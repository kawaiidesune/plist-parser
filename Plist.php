<?php
/**
 * Plist Parser Class
 * 
 * @author 		Véronique Bellamy (v@vero.moe) Original author is michaelfox
 * @copyright	2016 Véronique Bellamy. Some rights reserved. https://veroniquebellamy.fr/en/about/open-source/
 * @example		https://github.com/kawaiidesune/plist-parser/blob/master/README.md Block of code incorporated in the Usage section of the readme.
 * @license		GNU General Public License, version 3
 * @package		Plist
 * @todo		Refactor the class.
 * @todo		Write documentation for all the functions and public variables. :)
 */
class Plist {
	public $document; /** @todo Check to see if this variable is necessary, as nothing is ever assigned to it, it's only used for comparison in Plist::as_xml(). */
	public $plist_node; /** @todo Check to see if this variable is necessary, considering it is not used in the body of the code. */
	public $root; /** @todo Check to see if this variable is necessary, considering it is not used in the body of the code. */
	public $data = array(); /** @var array $data Where the data from the Plist file is stored. */
	/**
	 * Factory Methods
	 *
	 */
	/**
	 * @param string|null $file The file location of the plist file.
	 * @return DOMDocument The Plist file in question. Maybe this function should be renamed...
	 * @uses Plist::from_dom_document to set the DOM document and return that set document.
	 */
	public static function from_file($file) {
		if (!file_exists($file)) {
			throw new Exception("Unable to open plist file.");
		}
		$plist_document = new DOMDocument();
		$plist_document->load($file);
		return self::from_dom_document($plist_document);
	}
	/**
	 * @param DOMDocument $plist_document A DOMDocument to set the DOM Document.
	 * @todo Review if this function is necessary, considering no other function in the document seems to use it.
	 */
	public static function from_dom_document(DOMDocument $plist_document) {
		$plist = new self();
		$plist->set_dom_document($plist_document);
		return $plist;
	}
	/**
	 * Instance Methods
	 *
	 */
	public function __construct() {}

	/**
	 * @return string|NULL
	 * @uses Plist::as_xml() 
	 */
	public function __toString() {
		if ($xml = $this->as_xml()) {
			return $xml;
		}
		if (!empty($this->data['Label'])) {
			return $this->data['Label'];
		}
		return NULL;
	}
	/**
	 * @param string|int $key Specifies the key in the Plist::data array so data can be pulled from that array.
	 */
	public function __get($key) {
		if (!empty($this->data[$key])) {
			return $this->data[$key];
		}
		return NULL;
	}
	/**
	 * @return string|NULL
	 * @uses DOMDocument::saveXML
	 * @uses Plist::document
	 */
	public function as_xml() {
		if (is_a($this->document, "DOMDocument")) {
			return $this->document->saveXML();
		}
		return NULL;
	}
	public function as_array() {
		return (array) $this->data;
	}
	/**
	 * Helper Methods
	 * @todo Figure out how exactly these are being used, because for the life of me, I can't see how they're being used in this class...
	 */
	/**
	 * @param DOMNode $value_node
	 * @return array|bool|int|string|NULL
	 * @uses DOMNode::nodeName
	 * @uses Plist::parse_array
	 * @uses Plist::parse_date
	 * @uses Plist::parse_dict
	 * @uses Plist::parse_false
	 * @uses Plist::parse_integer
	 * @uses Plist::parse_string
	 * @uses Plist::parse_true
	 * @var string $value_type Stores the value type generated by DOMNode::nodeName.
	 */
	public static function parse_value($value_node) {
		$value_type = $value_node->nodeName;
		$transformer_name = "parse_$value_type";
		$class = get_class();
		if ( is_callable("{$class}::{$transformer_name}") ) {
			// there is a transformer function for this node type
			return call_user_func(array($class, $transformer_name), $value_node);
		}
		// if no transformer was found
		return NULL;
	}
	/**
	 * @return string Though, as it is going into an array, it would be turned into an integer if it is a valid integer.
	 * @see http://php.net/manual/en/language.types.array.php
	 * @uses DOMNode::textContent
	 */
	public static function parse_integer( $node ) {
		return $node->textContent;
	}
	/**
	 * @param DOMDocument $node
	 * @return string
	 * @uses DOMNode::textContent
	 */
	public static function parse_string( $node ) {
		return $node->textContent;
	}
	/**
	 * @return string
	 * @see http://php.net/manual/en/class.datetime.php
	 * @todo See if it can be parsed into a DateTime variable type instead...
	 * @uses DOMNode::textContent
	 */
	public static function parse_date( $node ) {
		return $node->textContent;
	}
	/**
	 * @return bool Though, if it is going into an array, it would be turned into an integer (in this case, 1).
	 * @see http://php.net/manual/en/language.types.array.php
	 */
	public static function parse_true( $node ) {
		return true;
	}
	/**
	 * @return bool Though, if it is going into an array, it would be turned into an integer (in this case, 0).
	 * @see http://php.net/manual/en/language.types.array.php
	 */
	public static function parse_false( $node ) {
		return false;
	}
	/**
	 * @param array $dict_node
	 * @return
	 * @uses Plist::parse_value()
	 */
	public static function parse_dict( $dict_node ) {
		$dict = array();
		// for each child of this node
		for (
		  $node = $dict_node->firstChild;
		  $node != null;
		  $node = $node->nextSibling
		) {
			if ( $node->nodeName == "key" ) {
				$key = $node->textContent;
				$value_node = $node->nextSibling;
				// skip text nodes
				while ( $value_node->nodeType == XML_TEXT_NODE ) {
					$value_node = $value_node->nextSibling;
				}
				// recursively parse the children
				$value = self::parse_value($value_node);
				$dict[$key] = $value;
			}
		}
		return $dict;
	}
	/**
	 * @return array
	 * @uses Plist::parse_value()
	 */
	public static function parse_array( $array_node ) {
		$array = array();
		for (
		  $node = $array_node->firstChild;
		  $node != null;
		  $node = $node->nextSibling
		) {
			if ( $node->nodeType == XML_ELEMENT_NODE ) {
				array_push($array, self::parse_value($node));
			}
		}
		return $array;
	}
}
?>